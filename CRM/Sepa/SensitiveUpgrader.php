<?php

/**
 * Perform DB upgrades as needed.
 *
 * Unlike the standard upgrade mechanism in CiviCRM --
 * and by extension, the extension upgrade code auto-generated by civix --
 * this implementation doesn't rely on version numbers.
 * Rather, each individual upgrade task comes with a test
 * to check whether this tasks needs to be performed.
 *
 * This is more robust, and way more flexible.
 * Most notably you do not run into problem when doing development
 * or generally running experimental versions with changes that aren't upstream yet,
 * and later rebasing/upgrading to new upstream versions.
 *
 * The implementation is partially inspired by the civix-generated upgrader;
 * but it's quite different in many ways, and inherits only very small bits of code.
 */
abstract class CRM_Sepa_SensitiveUpgrader {
  /**
   * Return list of all potential upgrade tasks.
   *
   * @return array List of ($title, $check, $action) tuples describing each task.
   *   $title is a descriptive title, displayed during the upgrade (and saved in the log).
   *   $check is a callback function, returning a bool to indicate whether the task needs to be run.
   *   $action is a callback function actually performing the upgrade task.
   *     It should return an array of string messages,
   *     describing the action(s) that have been (sucessfully) performed.
   */
  # Abstract definition not actually enabled,
  # because it throws a "Strict Standards" warning with PHP < 7,
  # although it makes perfect sense (and works fine apart from the warning) since PHP 5.3
  #
  # This doesn't really affect functionality --
  # the compiler just won't detect a missing/wrong implementation in child classes.
  #abstract protected static function tasks();

  /**
   * Check whether any DB upgrades are necessary.
   *
   * Runs the check() callbacks of all upgrade tasks in tasks(),
   * to see whether any of them signals the need for an upgrade.
   */
  public static function checkUpgradeNeeded() {
    foreach (static::tasks() as $task) {
      if (call_user_func($task['check'])) {
        return true;
      }
    }
    return false;
  }

  /**
   * Put any necessary upgrade tasks in the queue.
   *
   * Create upgrade queue entries for each task in tasks()
   * that signals the need for an upgrade,
   * so the queue runner will invoke the corresponding actions.
   *
   * @param $queue CRM_Queue_Queue List to be filled with upgrade tasks to perform
   */
  public static function enqueueUpgrades(CRM_Queue_Queue $queue) {
    foreach (static::tasks() as $name => $task) {
      if (call_user_func($task['check'])) {
        $task = new CRM_Queue_Task(
          array(get_called_class(), $name), /* Set CRM_Sepa_Upgrade::$name as callback -- will be resolved by the magic __callStatic() dispatcher. */
          array(), /* Don't need to pass any parameters to the callback. */
          $task['title']
        );
        $queue->createItem($task);
      }
    }
  }

  /**
   * Dispatcher invoking the specific upgrade action for a task.
   *
   * The queue runner will invoke $upgaderClass::$taskName() for each task.
   * This function looks up and invokes the specific action from the $tasks array.
   *
   * @param $name string Name of the method (i.e. upgrade task) requested
   * @param $arguments array($ctx, ...) Arguments the method is invoked with.
   *   The first argument is always the queue context. (Which we use only for logging.)
   *   Other arguments could be passed when enqueuing the task -- but we don't need that.
   */
  public static function __callStatic($name, $arguments) {
    list($ctx) = $arguments;

    $task = CRM_Utils_array::value($name, static::tasks());
    if (!$task) {
      throw new CRM_Exception("Upgrade task '$name' doesn't exist");
    }

    $ctx->log->info($task['title']);
    $messages = call_user_func($task['action']);

    foreach ($messages as $message) {
      $ctx->log->info($message);

      /* When running within an API call, we try to pass the messages back to the caller,
       * as there seems to be no other way to make them visible to the user. */
      if (isset($GLOBALS['sepa_upgrade_messages'])) {
        $GLOBALS['sepa_upgrade_messages'][] = $message;
      }
    }

    return true; /* Indicate success. */
  }
}
